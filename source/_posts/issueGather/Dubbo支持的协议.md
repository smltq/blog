---
title: Dubbo支持的协议
date: 2019-12-31 00:12:57
categories: 
- Java
tags:
- 设计
- 原理
---

## 协议介绍

协议是两个网络实体进行通信的基础，数据在网络上从一个实体传输到另一个实体，以字节流的形式传递到对端。在这个字节流的世界里，如果没有协议，就无法将这个一维的字节流重塑成为二维或者多维的数据结构以及领域对象。

在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情。你可以根据你应用的创建来选择。例如，使用RMI协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用RMI协议，而是基于HTTP协议或者Hessian协议。

## 常见的协议模式

应用层协议一般的形式有三种：定长协议、特殊结束符和协议头+payload模式。

从网络上以流的形式进行数据的读取，需要确定的是一次有意义的传输内容在读到何时结束，因为一个一个byte传输过来，需要有一个结束。而且数据在网络上的传输，存在粘包和半包的情况，能够应对这个问题的办法就是协议能够准确的识别，当粘包发生时不会多读，当半包发生时会继续读取。

### 定长协议

定长的协议是指协议内容的长度是固定的，比如协议byte长度是50，当从网络上读取50个byte后，就进行decode解码操作。定长协议在读取或者写入时，效率比较高，因为数据缓存的大小基本都确定了，就好比数组一样，缺陷就是适应性不足，以RPC场景为例，很难估计出定长的长度是多少。

>可以参考Netty的FixedLengthFrameDecoder

### 特殊结束符

相比定长协议，如果能够定义一个特殊字符作为每个协议单元结束的标示，就能够以变长的方式进行通信，从而在数据传输和高效之间取得平衡，比如用特殊字符\n。

特殊结束符方式的问题是过于简单的思考了协议传输的过程，对于一个协议单元必须要全部读入才能够进行处理，除此之外必须要防止用户传输的数据不能同结束符相同，否则就会出现紊乱。

>可以参考Netty的DelimiterBasedFrameDecoder

### 变长协议（协议头+payload）

一般是自定义协议，会以定长加不定长的部分组成，其中定长的部分需要描述不定长的内容长度。

+———+
|定长|
+———+
|内容|
+———+

>可以参考Netty的LengthFieldBasedFrameDecoder

## Dubbo支持的协议

- Dubbo协议
- Hessian协议
- HTTP协议
- RMI协议
- WebService协议
- Thrift协议
- Memcached协议
- Redis协议

### Dubbo 协议

Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低

    缺省协议，使用基于mina1.1.7+hessian3.2.1的tbremoting交互。
    连接个数：单连接
    连接方式：长连接
    传输协议：TCP
    传输方式：NIO异步传输
    序列化：Hessian二进制序列化
    适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。
    适用场景：常规远程服务方法调用
    
### Hessian 协议

Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现基于Hessian的远程调用协议。

    连接个数：多连接
    连接方式：短连接
    传输协议：HTTP
    传输方式：同步传输
    序列化：Hessian二进制序列化
    适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件
    适用场景：页面传输，文件传输，或与原生hessian服务互操作
    
### HTTP 协议
    
采用Spring的HttpInvoker实现
    
    基于http表单的远程调用协议
    
    连接个数：多连接
    连接方式：短连接
    传输协议：HTTP
    传输方式：同步传输
    序列化：表单序列化（JSON）
    适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件
    适用场景：需同时给应用程序和浏览器JS使用的服务。

### RMI 协议

RMI协议采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式

    Java标准的远程调用协议
    
    连接个数：多连接
    连接方式：短连接
    传输协议：TCP
    传输方式：同步传输
    序列化：Java标准二进制序列化
    适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。
    适用场景：常规远程服务方法调用，与原生RMI服务互操作
    
### WebService 协议

基于CXF的frontend-simple和transports-http实现

    基于WebService的远程调用协议
    
    连接个数：多连接
    连接方式：短连接
    传输协议：HTTP
    传输方式：同步传输
    序列化：SOAP文本序列化
    适用场景：系统集成，跨语言调用。
    
### Thrift 协议

Thrift是一个轻量级、跨语言的远程服务调用框架，最初由Facebook开发，后面进入Apache开源项目。它通过自身的IDL中间语言, 并借助代码生成引擎生成各种主流语言的RPC服务端/客户端模板代码。

当前 dubbo 支持的 thrift 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如service name，magic number等。

## 资料

- [Java问题收集](https://github.com/smltq/blog/blob/master/source/_posts/issueGather/index.md)
- [原文地址](https://github.com/smltq/blog/blob/master/source/_posts/issueGather/Dubbo%E6%94%AF%E6%8C%81%E7%9A%84%E5%8D%8F%E8%AE%AE.md)